curl is a command-line tool used to transfer data from or to a server using various protocols, including HTTP, HTTPS, FTP, and more. It is an essential tool for web enumeration and interacting with web applications during penetration testing.

**Basic Usage**

```
curl http://example.com
```

â€¢ Sends a **GET request** to the specified URL and outputs the response.

**Commonly Used Options**

|**Option**|**Description**|**Example**|
|---|---|---|
|-X|Specify the request method (GET, POST, etc.)|curl -X POST http://example.com|
|-d|Send data with the request (POST form data)|curl -d "username=admin&password=pass" http://example.com/login|
|-H|Add headers to the request|curl -H "User-Agent: CustomAgent" http://example.com|
|-A|Specify a custom User-Agent|curl -A "Mozilla/5.0" http://example.com|
|-L|Follow redirects|curl -L http://example.com|
|-i|Include response headers in the output|curl -i http://example.com|
|-k|Ignore SSL certificate errors|curl -k https://example.com|
|-o|Save output to a file|curl -o output.html http://example.com|
|-s|Silent mode (hide progress bar)|curl -s http://example.com|
|-u|Use basic authentication|curl -u admin:password http://example.com|
|--cookie|Send a cookie|curl --cookie "SESSIONID=12345" http://example.com|
|-b|Load cookies from a file|curl -b cookies.txt http://example.com|
|-c|Save cookies to a file|curl -c cookies.txt http://example.com|
|--proxy|Use a proxy server|curl --proxy http://127.0.0.1:8080 http://example.com|

**Practical Use Cases in OSCP**

  

**1. Enumerate HTTP Headers**

```
curl -I http://example.com
```

â€¢ Fetches and displays only the **response headers**.

**2. Enumerate Hidden Pages (Using a Wordlist)**

```
for page in $(cat wordlist.txt); do curl -s -o /dev/null -w "%{http_code} %{url_effective}\n" http://example.com/$page; done
```

â€¢ Loops through a wordlist and checks for HTTP response codes.

**3. Login to a Web Form (POST Request)**

```
curl -X POST -d "username=admin&password=pass" http://example.com/login
```

â€¢ Attempts to login by sending credentials as form data.

**4. Use Custom Headers**

```
curl -H "User-Agent: Mozilla/5.0" -H "Referer: http://evil.com" http://example.com
```

â€¢ **Modifies headers** to test for security misconfigurations.

**5. Test for SQL Injection**

```
curl -X POST -d "username=admin'--&password=" http://example.com/login
```

â€¢ Sends an SQL payload to check for vulnerabilities.

**6. Check if a Site Allows TRACE Method (Potential XST Attack)**

```
curl -X TRACE http://example.com
```

â€¢ If the response includes TRACE output, the site may be vulnerable to **Cross-Site Tracing (XST)**.

**7. Retrieve Web Content and Save to File**

```
curl -o index.html http://example.com
```

â€¢ Downloads a webpage and saves it as index.html.

**8. Use Burp Suite as a Proxy**

```
curl --proxy http://127.0.0.1:8080 http://example.com
```

â€¢ Routes traffic through **Burp Suite** for interception.

**9. Bypass SSL Certificate Validation**

```
curl -k https://example.com
```

â€¢ Useful when testing self-signed SSL certificates.

**10. Use curl to Extract Comments and Keywords from Source Code**

```
curl -s http://example.com | grep -E "TODO|DEBUG|password|api_key|admin"
```

â€¢ Searches for **sensitive information** in the response.

**11. Test for LFI (Local File Inclusion)**

```
curl http://example.com/page.php?file=../../../../etc/passwd
```

â€¢ Attempts to read /etc/passwd.

**12. Fetch JavaScript Files and Search for Endpoints**

```
curl -s http://example.com/script.js | grep -oE "https?://[a-zA-Z0-9./?=_-]*"
```

â€¢ Finds **hidden API endpoints** or URLs within JavaScript files.

**13. Perform SSRF (Server-Side Request Forgery) Tests**

```
curl -X GET "http://example.com/proxy?url=http://169.254.169.254/latest/meta-data/"
```

â€¢ Attempts **SSRF** to access cloud instance metadata.

**14. Bruteforce API Endpoints (Using SecLists)**

```
for url in $(cat /usr/share/seclists/Discovery/Web-Content/api-endpoints.txt); do curl -s -o /dev/null -w "%{http_code} %{url_effective}\n" http://example.com/$url; done
```

â€¢ Uses a wordlist to identify **hidden API endpoints**.

**15. Bypass WAF Using Headers**

```
curl -X GET http://example.com -H "X-Original-URL: /admin"
```

â€¢ Some **WAFs** only filter requests based on standard URLs.

**16. Check for Open Redirects**

```
curl -v "http://example.com/?redirect=http://evil.com"
```

â€¢ Tests if the site redirects to an **external domain**.

**17. Upload a File via curl**

```
curl -X POST -F "file=@shell.php" http://example.com/upload.php
```

â€¢ Attempts to **upload a shell**.

**18. Attempt HTTP PUT File Upload**

```
curl -X PUT --data-binary @shell.php http://example.com/uploads/shell.php
```

â€¢ If the server supports **PUT**, you may be able to upload a shell.

**Conclusion**

  

curl is a **powerful** tool for **web enumeration** and **exploitation**. It helps in:

âœ… **Extracting information** from web servers

âœ… **Testing for vulnerabilities** (SQLi, LFI, SSRF, etc.)

âœ… **Automating API and directory enumeration**

âœ… **Working with proxies (Burp Suite, SOCKS, etc.)**

âœ… **Bypassing WAF protections**

**ðŸ”¥ Pro Tip for OSCP**

â€¢ **Use curl -i** to inspect headers for potential vulnerabilities.

â€¢ **Check robots.txt** using curl http://example.com/robots.txt.

â€¢ **Test for default credentials** with curl -u admin:admin.

â€¢ **Always log responses** with -o output.txt for later analysis.

Let me know if you need **more examples** or **specific attack scenarios!** ðŸš€